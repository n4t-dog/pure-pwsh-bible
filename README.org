* TODO STRINGS
** Trim leading and trailing white-space from string
#+begin_src powershell
  PS> "    Hello,  World    ".Trim()
  Hello, World

  PS> $name = "   John Black  "
  PS> $name.Trim()
  John Black
#+end_src
** Trim all white-space from string and truncate spaces
#+begin_src powershell
  PS> [regex]::Replace("    Hello,    World    ","`\s+"," ").Trim()
  Hello, World

  PS> [regex]::Replace("   John   Black  is     my    name.    ","`\s+"," ").Trim()
  John Black is my name.
#+end_src
** TODO Use regex on a string
#+begin_src powershell
  # Trim leading white-space
  PS> [regex]::Replace("   hello", "^\s+","")
  hello

  # Validate a hex color
  PS>

  # Validate a hex color (invalid).
  PS>
#+end_src
** Split a string on a delimiter
#+begin_src powershell
  PS> "apples,oranges,pears,grapes".Split(",")
  apples
  oranges
  pears
  grapes

  # Cleaner method
  PS> "1, 2, 3, 4, 5" -split ", "
  1
  2
  3
  4
  5

  # Multi char delimiters work too!
  PS> "hello---world---my---name---is---john" -split "---"
  hello
  world
  my
  name
  is
  john
#+end_src
** Change a string to lowercase
#+begin_src powershell
  PS> "HELLO".ToLower()
  hello

  PS> "HeLlO".ToLower()
  hello

  PS> "hello".ToLower()
  hello
#+end_src
** Change a string to uppercase
#+begin_src powershell
  PS> "hello".ToUpper()
  HELLO

  PS> "HeLlO".ToUpper()
  HELLO

  PS> "HELLO".ToUpper()
  HELLO
#+end_src
** Reverse a string case
*** Example Function:
#+begin_src powershell
  function reverse_case([string]$1){
    $s = ""
    forEach($c in $1.ToCharArray()){
      if($c -ge [char]'a'){
        $s+="$c".ToUpper()
      } else {
        $s+="$c".ToLower()
      }
    }
    return $s
  }
#+end_src
*** Example Usage:
#+begin_src powershell
  PS> reverse_case "hello"
  HELLO

  PS> reverse_case "HeLlO"
  hElLo

  PS> reverse_case "HELLO"
  hello
#+end_src
** Trim quotes from a string
#+begin_src powershell
  PS> $var="'Hello', `"World`""
  PS> $var.replace("'","").replace("`"","")
  Hello, World
#+end_src
** Strip all instance of pattern from string
#+begin_src powershell
  # Regex version
  PS> [regex]::Replace("The Quick Brown Fox", "[aeiou]", "")
  Th Qck Brwn Fx

  # String only
  PS> "The Quick Brown Fox".Replace(" ","")
  TheQuickBrownFox

  # String works for regex
  PS> [regex]::Replace("The Quick Brown Fox", "Quick ", "")
  The Brown Fox
#+end_src
** TODO Strip first occurrence of pattern from string
** TODO Strip pattern from start of string
** TODO Strip pattern from end of string
** TODO Percent-encode a string
** TODO Decode a percent-encoded string
** Check if string contains a sub-string
*** Using a test:
#+begin_src powershell
  if ($var -like "*sub_string*") {
    "sub_string is in var."
  }

  # Inverse (substring not in string).
  if($var -notlike "*sub_string*") {
    "sub_string is not in var."
  }

  # This works for arrays too!
  if($arr -like "*sub_string*") {
    "sub_string is in array."
  }
#+end_src
*** Using a switch statement:
#+begin_src powershell
  switch ($var) {
    {$_ -like "*sub_string*"}{
      # Do stuff
    }
    {$_ -like "*sub_string2*"}{
      # Do more stuff
    }
    default{
      # Else
    }
  }
#+end_src
** Check if string starts with sub-string
#+begin_src powershell
  if ($var -like "sub_string*") {
    "var starts with sub_string."
  }

  # Inverse (var does not start with sub_string).
  if ($var -notlike "sub_string*") {
    "var does not start with sub_string."
  }
#+end_src
** Check if string ends with sub-string
#+begin_src powershell
  if ($var -like "*sub_string") {
    "var ends with sub_string."
  }

  # Inverse (var does not end with sub_string).
  if ($var -notlike "*sub_string") {
    "var does not end with sub_string."
  }
#+end_src
* TODO ARRAYS
** Reverse an array
#+begin_src powershell
  # Using range operator
  (1,2,3,4,5)[4..0]

  # Dynamic
  $arr = "red","blue","green"
  $arr[$arr.Count..0]
#+end_src
** Remove duplicate array elements
#+begin_src powershell
  # With Select-Object
  (1,1,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,5) | Select-Object -Unique

  # With Sort-Object
  $arr = "red","red","green","blue","blue"
  $arr | Sort-Object -Unique
#+end_src
** Random array element
#+begin_src powershell
  $array = "red","green","blue","yellow","brown"
  Get-Random -InputObject $array

  # Directly pass
  Get-Random -InputObject (1,2,3,4,5,6,7)
#+end_src
** Cycle through an array
#+begin_src powershell
  $arr = "a","b","c","d"

  function cycle{
    $arr[${i}?${i}:0]
    $script:i=$i -ge $arr.Count-1?0:++$i
  }
#+end_src
** Toggle between two values
#+begin_src powershell
  $arr = $True, $False

  function cycle{
    $arr[${i}?${i}:0]
    $script:i=$i -ge $arr.Count-1?0:++$i
  }
#+end_src
* TODO LOOPS
** Loop over a range of numbers
#+begin_src powershell
  # Loop from 0-100 with foreach
  foreach($i in 0..100){$i}

  # With for
  for($i=0;$i -le 100;$i++){$i}

  # With ForEach-Object
  0..100 | ForEach-Object{$_}
#+end_src
** Loop over a variable range of numbers
#+begin_src powershell
  # Loop from 0-VAR
  $VAR=50

  # With foreach
  foreach($i in 0..$VAR){$i}

  # With for
  for($i=0;$i -le $VAR;$i++){$i}

  # With ForEach-Object
  0..$VAR | ForEach-Object {$_}
#+end_src
** Loop over an array
#+begin_src powershell
  $arr = "apples","oranges","tomatoes"

  # With foreach
  foreach($element in $arr){$element}

  # With ForEach-Object
  $arr | ForEach-Object {$_}
#+end_src
** Loop over an array with an index
#+begin_src powershell
  $arr = "apples","oranges","tomatoes"

  # With for
  for($i=0;$i -lt $arr.Count;$i++){$arr[$i]}

  # With foreach
  foreach($i in 0..($arr.Count-1)){$arr[$i]}

  # With ForEach-Object
  0..($arr.Count-1) | ForEach-Object{$_}
#+end_src
** Loop over the contents of a file
#+begin_src powershell
  # With for
  $file = Get-Content "file"
  for($i=0;$i -lt $file.Count;$i++){$file[$i]}

  # With foreach
  foreach($l in (Get-Content "file")){$l}

  # With ForEach-Object
  Get-Content "file" | ForEach-Object{$_}
#+end_src
** Loop over files and directories
*Self Note*: Populates list with file globbing. Apparently trying to avoid listing files. Not possible with PowerShell
#+begin_src powershell
  # All files
  foreach($file in (Get-ChildItem)){
    $file
  }

  # PNG files in dir
  foreach($file in (Get-ChildItem ~/Pictures/*.png)){
    $file
  }

  # Iterate over directories
  foreach($dir in (Get-ChildItem ~/Downloads -Directory)){
    $dir
  }

  # "Brace Expansion"
  foreach($file in ("file1","file2","subdir/file3"|%{"/path/to/parentdir/"+$_})){
    $file
  }

  # Iterate recursively
  foreach($file in (Get-ChildItem ~/Pictures -Recurse -File){
    $file
  }
#+end_src
* TODO FILE HANDLING
** Read a file to a string
#+begin_src powershell
  (Get-Content "file") -join "`n"
#+end_src
** Read a file to an array (by line)
#+begin_src powershell
  # All lines
  Get-Content "file"

  # Remove blank lines
  Get-Content "file" | Where-Object {$_}

  # Remove blank/whitespace lines
  Get-Content "file" | Where-Object {$_.Trim()}
#+end_src
** Get the first N lines of a file
#+begin_src powershell
  Get-Content "file" -TotalCount <n>
#+end_src
** Get the last N lines of a file
#+begin_src powershell
  Get-Content "file" -Tail <n>
#+end_src
** Get the number of lines in a file
#+begin_src powershell
  # Normal
  (Get-Content "file").Count

  # Memory friendly (.NET 4+)
  [System.IO.File]::ReadLines("file") | Measure-Object -Line

  # Memory friendly
  $count = 0
  $reader = [System.IO.File]::OpenText("file")
  while($reader.ReadLine() -ne $null){
    $count++
  }
  $count
#+end_src
** Count files or directories in directory
#+begin_src powershell
  # Count all files in dir.
  (Get-ChildItem ~/Downloads).Count

  # Count all dirs in a dir.
  (Get-ChildItem ~/Downloads -Directory).Count

  # Count all jpg files in dir.
  (Get-ChildItem ~/Pictures/*.jpg).Count
#+end_src
** Create an empty file
#+begin_src powershell
  # Shortest
  "">file

  # Proper methods
  New-Item "file"
  "" | Out-File "file"
#+end_src
** Extract lines between two markers
*** Example Function
#+begin_src powershell
  function extract($1,$2,$3){
    $lines=$extract=""
    Get-Content $1 | %{
      if($extract -and $_ -ne $3){
        $lines+=$_+"`n"
      }
      if($_ -eq $2){$extract=$True}
      if($_ -eq $3){$extract=$False}
    }
    return $lines
  }
#+end_src
* TODO FILE PATHS
** TODO Get the directory name of a file path
** TODO Get the base-name of a file path
* TODO VARIABLES
** TODO Assign and access a variable using a variable
** TODO Name a variable based on another variable
* TODO ESCAPE SEQUENCES
** Text Colors
Using $PSStyle (added PowerShell 7.2)
#+begin_src powershell
  # Using 16 Console Color names
  $PSStyle.Foreground.<ConsoleColor>
  $PSStyle.Background.<ConsoleColor>
  # Using RGB values
  $PSStyle.Foreground.FromRgb(<R>,<G>,<B>)
  $PSStyle.Background.FromRgb(<R>,<G>,<B>)
  # Using HEX values
  $PSStyle.Foreground.FromRgb(0x<hexcolor>)
  $PSStyle.Background.FromRgb(0x<hexcolor>)
#+end_src
Pre PowerShell 7.2
| Sequence             | What does it do?                        | Value |
|----------------------+-----------------------------------------+-------|
| =`e[38;5;<NUM>m=       | Set text foreground color.              | =0-255= |
| =`e[48;5;<NUM>m=       | Set text background color.              | =0-255= |
| =`e[38;2;<R>;<G>;<B>m= | Set text foreground color to RGB color. | R,G,B |
| =`e[48;2;<R>;<G>;<B>m= | Set text background color to RGB color. | R,G,B |
** Text Attributes
$PSStyle available for PowerShell 7.2+, =$PSStyle.Bold= will create bold text, append =Off= to turn an effect off ie: =$PSStyle.BoldOff=
| Sequence | What does it do                   | $PSStyle      |
|----------+-----------------------------------+---------------|
| `e[m     | Reset text formatting and colors. | Reset         |
| `e[1m    | Bold text.                        | Bold          |
| `e[2m    | Faint text.                       | N/A           |
| `e[3m    | Italic text.                      | Italic        |
| `e[4m    | Underline text.                   | Underline     |
| `e[5m    | Blinking text.                    | Blink         |
| `e[7m    | Highlighted text.                 | Reverse       |
| `e[8m    | Hidden text.                      | Hidden        |
| `e[9m    | Strike-through text.              | Strikethrough |
** TODO Cursor Movement
Untested
| Sequence            | What does it do?                    | Value       |
|---------------------+-------------------------------------+-------------|
| `e[<LINE>;<COLUMN>H | Move cursor to absolute position.   | line,column |
| `e[H                | Move cursor to home position (0,0). |             |
| `e[<NUM>A           | Move cursor up N lines.             | num         |
| `e[<NUM>B           | Move cursor down N lines.           | num         |
| `e[<NUM>C           | Move cursor right N columns.        | num         |
| `e[<NUM>D           | Move cursor left N columns.         | num         |
| `e[s                | Save cursor position.               |             |
| `e[u                | Restore cursor position.            |             |
** TODO Erasing Text
Untested
| Sequence | What does it do?                                         |
|----------+----------------------------------------------------------|
| `e[K     | Erase from cursor position to end of line.               |
| `e[1K    | Erase from cursor position to start of line.             |
| `e[2K    | Erase the entire current line.                           |
| `e[J     | Erase from the current line to the bottom of the screen. |
| `e[1J    | Erase from the current line to the top of the screen.    |
| `e[2J    | Clear the screen.                                        |
| `e2J`e[H | Clear the screen and move cursor to =0,0=.                 |
* TODO PARAMETER EXPANSION
** TODO Indirection
** TODO Replacement
** TODO Length
** TODO Expansion
** TODO Case Modification
** TODO Default Value

* TODO BRACE EXPANSION
** Ranges
#+begin_src powershell
  # Syntax: <START>..<END>

  # Print numbers 1-100
  1..100

  # Print range of floats
  11..19 | ForEach-Object {$_/10}
  # As strings
  1..9 | ForEach-Object {"1.$_"}

  # Print chars a-z. (PowerShell 6+)
  'a'..'z'
  'A'..'Z'

  # Nesting (A0,A1,...,Z9)
  foreach($l in 'A'..'Z'){foreach($i in 0..9){"$l$i"}}
  # NOTE: situation where foreach and ForEach-Object are NOT interchangeable

  # Print zero-padded numbers.
  1..100 | ForEach-Object {"$_".PadLeft(2,'0')}

  # Change increment amount
  1..5 | ForEach-Object {$_*2-1}

  # Increment backwards
  5..-5

  # Variable range
  $VAR=50
  1..50
#+end_src
** String Lists
#+begin_src powershell
  "apples","oranges","pears","grapes"

  # Example Usage:
  # Remove dirs Movies, Music and ISOS from ~/Downloads/.
  "Movies","Music","ISOS" | ForEach-Object {Remove-Item -Force "~/Downloads/"+$_}
#+end_src
* TODO CONDITIONAL EXPRESSIONS
** TODO File Conditionals
** TODO File Comparisons
** TODO Variable Conditionals
** TODO Variable Comparisons
* TODO ARITHMETIC OPERATORS
** TODO Assignment
** TODO Arithmetic
** TODO Bitwise
** TODO Logical
** TODO Miscellaneous
* TODO ARITHMETIC
** TODO Simpler syntax to set variables
** TODO Ternary Tests
* TODO TRAPS
** TODO Do something on script exit
** TODO Ignore terminal interrupt (CTRL+C, SIGINT)
** TODO React to window resize
** TODO Do something before every command
** TODO Do something when a shell function or a sourced file finishes executing
* TODO PERFORMANCE
** TODO Disable Unicode
* TODO OBSOLETE SYNTAX
** TODO Shebang
** TODO Command Substitution
** TODO Function Declaration
* TODO INTERNAL VARIABLES
** Get the location to the pwsh binary
#+begin_src powershell
  $PSHOME
#+end_src
** Get the version of the current running pwsh process
#+begin_src powershell
  # Via Host (emulator dependent)
  $Host.Version
  # Via engine
  $PSVersionTable.PSVersion
#+end_src
** Open the user's preferred text editor
#+begin_src powershell
  # NOTE: Acts as if file has been double clicked
  Invoke-Item $file
#+end_src
** Get the name of the current function
#+begin_src powershell
  # Current function
  (Get-PSCallStack)[0]

  # Alternative
  $MyInvocation.MyCommand

  # Parent function
  (Get-PSCallStack)[1]

  # So on and so forth
  (Get-PSCallStack)[2]
  (Get-PSCallStack)[3]

  # All functions including parents
  Get-PSCallStack
#+end_src
** Get the host-name of the system
#+begin_src powershell
  # Proper
  [System.Environment]::MachineName

  # Golfed
  [Environment]::MachineName
#+end_src
** Get the architecture of the Operating System
#+begin_src powershell
  # Proper
  [System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture

  # Golfed
  [Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture

  # Bit Width
  [Environment]::Is64BitOperatingSystem
#+end_src
** Get the name of the Operating System / Kernel
#+begin_src powershell
  # Proper
  [System.Environment]::OSVersion

  # Golfed
  [Environment]::OSVersion
#+end_src
** Get the current working directory
#+begin_src powershell
  $PWD
#+end_src
** Get the number of seconds the script has been running
#+begin_src powershell
  (Get-History -Count 1).EndExecutionTime - (Get-History 1).StartExecutionTime
#+end_src
** Get a pseudorandom integer
#+begin_src powershell
 Get-Random
#+end_src
* TODO INFORMATION ABOUT THE TERMINAL
** Get the terminal size in lines and columns (from a script)
#+begin_src powershell
  $Host.UI.RawUI.WindowSize
#+end_src
** TODO Get the terminal size in pixels
#+begin_src powershell

#+end_src
** Get the current cursor position
#+begin_src powershell
  $Host.UI.RawUI.CursorPosition
#+end_src
* TODO CONVERSION
** Convert a hex color to RGB
*** Example Function
#+begin_src powershell
  function hex_to_rgb([string]$1){
    # Usage: hex_to_rgb "#FFFFFF"
    #        hex_to_rgb "000000"
    $t = $1.TrimStart("#")
    $r = [Convert]::ToInt32($t.Substring(0,2),16)
    $g = [Convert]::ToInt32($t.Substring(2,2),16)
    $b = [Convert]::ToInt32($t.Substring(4,2),16)
    return "$r $g $b"
  }
#+end_src
*** Example Usage
#+begin_src powershell
  PS> hex_to_rgb "#FFFFFF"
  255 255 255
#+end_src
** Convert an RGB color to hex
*** Example Function
#+begin_src powershell
  function rgb_to_hex($1,$2,$3){
    # Usage: rgb_to_hex "r" "g" "b"
    $r = [Convert]::ToString($1,16)
    $r+= [Convert]::ToString($2,16)
    $r+= [Convert]::ToString($3,16)
    return "#"+$r.ToUpper()
  }
#+end_src
*** Example Usage
#+begin_src powershell
  PS> rgb_to_hex "255" "255" "255"
  #FFFFFF
#+end_src
* TODO CODE GOLF
** Shorter =for= loop syntax
#+begin_src powershell
  # ForEach-Object
  1..10|%{$_}
  # foreach loop
  foreach($i in 1..10){$i}
  # for loop
  for($i=0;$i++ -lt 10;){$i}
#+end_src
** Shorter infinite loops
#+begin_src powershell
  # Normal method
  while(1){"hi"}

  # Shorter
  for(;;){"hi"}
#+end_src
** TODO Shorter function declaration
** TODO Shorter =if= syntax
** TODO Simpler =case= statement to set variable
** Misc/Notes
https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2
* TODO OTHER
** Use =Start-Sleep= as an alternative to the =sleep= command
#+begin_src powershell
  Start-Sleep 1
  Start-Sleep 0.1
  Start-Sleep 30
#+end_src
** Check if a program is in the user's PATH
#+begin_src powershell
  # As a test.
  if(Get-Command executable_name -CommandType Application -ErrorAction Ignore){
    # Program is in PATH.
  }

  # Inverse
  if(-not(Get-Command executable_name -CommandType Application -ErrorAction Ignore)){
    # Program is not in PATH.
  }

  # Golfed example
  if(gcm convert -c Ap 2>$null){
    "error: convert is not installed, exiting..."
    exit 1
  }
#+end_src
** Get the current date using =Get-Date=
#+begin_src powershell
  Get-Date
#+end_src
** Get the username of the current user
#+begin_src powershell
  # Proper
  [System.Environment]::UserName

  # Golfed
  [Environment]::UserName
#+end_src
** Generate a UUID V4
#+begin_src powershell
  New-Guid
#+end_src
** Progress bars
#+begin_src powershell
  # NOTE: Activity is required default parameter
  Write-Progress "[Title]" -PercentComplete $Elapsed

  # Set total length in chars
  $PSStyle.Progress.MaxWidth = 18
  # 0 for whole console, minimum 18, default 120
#+end_src
** Get the list of functions in a script
#+begin_src powershell
  Get-ChildItem Function:
#+end_src
** TODO Bypass shell aliases
** TODO Bypass shell functions
** TODO Run a command in the background
** Capture function return without command substitution
*Self note*: I think the original is a "pass by reference" method
#+begin_src powershell
  function to_upper([ref]$1){
    $1.Value = $1.Value.ToUpper()
  }

  $foo="bar"
  to_upper $foo
  $foo # BAR
#+end_src
